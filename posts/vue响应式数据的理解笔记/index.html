<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Vue响应式数据的理解笔记 | 浅岸的博客</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="theme: scrolls-light 图片及部分文章参考出处
响应式原理 数据响应式系统，其非侵入性的响应式系统，是vue最独特的特性之一。数据模型是被代理的JavaScript对象。而当修改它们的时候，视图就会进行更新。
当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。
这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。这里需要注意的是不同浏览器在控制台打印数据对象时对 getter/setter 的格式化并不同，所以建议安装 vue-devtools 来获取对检查数据更加友好的用户界面。
每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染
由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性
getter和setter的用法 const obj3 = {  firstName: &#39;chen&#39;,  lastName: &#39;shanqiong&#39;,  get name() {  return this.firstName &#43; this.">
    <meta name="generator" content="Hugo 0.97.3" />
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    
    
    
      

    

    
    
    <meta property="og:title" content="Vue响应式数据的理解笔记" />
<meta property="og:description" content="theme: scrolls-light 图片及部分文章参考出处
响应式原理 数据响应式系统，其非侵入性的响应式系统，是vue最独特的特性之一。数据模型是被代理的JavaScript对象。而当修改它们的时候，视图就会进行更新。
当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。
这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。这里需要注意的是不同浏览器在控制台打印数据对象时对 getter/setter 的格式化并不同，所以建议安装 vue-devtools 来获取对检查数据更加友好的用户界面。
每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染
由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性
getter和setter的用法 const obj3 = {  firstName: &#39;chen&#39;,  lastName: &#39;shanqiong&#39;,  get name() {  return this.firstName &#43; this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://zkh176.github.io/posts/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E7%90%86%E8%A7%A3%E7%AC%94%E8%AE%B0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-19T17:47:17+08:00" />
<meta property="article:modified_time" content="2022-04-19T17:47:17+08:00" />

<meta itemprop="name" content="Vue响应式数据的理解笔记">
<meta itemprop="description" content="theme: scrolls-light 图片及部分文章参考出处
响应式原理 数据响应式系统，其非侵入性的响应式系统，是vue最独特的特性之一。数据模型是被代理的JavaScript对象。而当修改它们的时候，视图就会进行更新。
当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。
这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。这里需要注意的是不同浏览器在控制台打印数据对象时对 getter/setter 的格式化并不同，所以建议安装 vue-devtools 来获取对检查数据更加友好的用户界面。
每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染
由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性
getter和setter的用法 const obj3 = {  firstName: &#39;chen&#39;,  lastName: &#39;shanqiong&#39;,  get name() {  return this.firstName &#43; this."><meta itemprop="datePublished" content="2022-04-19T17:47:17+08:00" />
<meta itemprop="dateModified" content="2022-04-19T17:47:17+08:00" />
<meta itemprop="wordCount" content="122">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Vue响应式数据的理解笔记"/>
<meta name="twitter:description" content="theme: scrolls-light 图片及部分文章参考出处
响应式原理 数据响应式系统，其非侵入性的响应式系统，是vue最独特的特性之一。数据模型是被代理的JavaScript对象。而当修改它们的时候，视图就会进行更新。
当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。
这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。这里需要注意的是不同浏览器在控制台打印数据对象时对 getter/setter 的格式化并不同，所以建议安装 vue-devtools 来获取对检查数据更加友好的用户界面。
每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染
由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性
getter和setter的用法 const obj3 = {  firstName: &#39;chen&#39;,  lastName: &#39;shanqiong&#39;,  get name() {  return this.firstName &#43; this."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        浅岸的博客
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>
    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">Vue响应式数据的理解笔记</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2022-04-19T17:47:17+08:00">April 19, 2022</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><hr>
<h2 id="theme-scrolls-light">theme: scrolls-light</h2>
<p><a href="https://cn.vuejs.org/v2/guide/reactivity.html">图片及部分文章参考出处</a></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f63fde027a974a879b54724e27cad5ea~tplv-k3u1fbpfcp-watermark.image?" alt="data.png"></p>
<h1 id="响应式原理">响应式原理</h1>
<p>数据响应式系统，其非侵入性的响应式系统，是vue最独特的特性之一。数据模型是被代理的JavaScript对象。而当修改它们的时候，视图就会进行更新。</p>
<p>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p>
<p>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。这里需要注意的是不同浏览器在控制台打印数据对象时对 getter/setter 的格式化并不同，所以建议安装 vue-devtools 来获取对检查数据更加友好的用户界面。</p>
<p>每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染</p>
<p>由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性</p>
<h1 id="getter和setter的用法">getter和setter的用法</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">obj3</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">firstName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;chen&#39;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">lastName</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;shanqiong&#39;</span>,
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">name</span>() {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">firstName</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lastName</span>
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">name</span>(<span style="color:#a6e22e">name</span>) {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">firstName</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">name</span>[<span style="color:#ae81ff">0</span>],
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">lastName</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">name</span>.<span style="color:#a6e22e">substring</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">age</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">18</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">obj3</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;李四&#39;</span>; <span style="color:#75715e">//相当于触发了setter函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;obj3的姓名：&#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">obj3</span>.<span style="color:#a6e22e">name</span>) <span style="color:#75715e">//obj3的姓名：李四
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">//在方法名之前加一个get 这样不加括号也可以调用  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//getter就是在函数名前面加get 
</span></span></span></code></pre></div><ul>
<li>需要注意的点</li>
<li>get name()的写法，不要忘记加括号（ES6新语法）</li>
</ul>
<h2 id="vue中数组的变异方法">vue中数组的变异方法</h2>
<p>Vue将被侦听的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹的方法包括：</p>
<ul>
<li><code>push()</code></li>
<li><code>pop()</code></li>
<li><code>shift()</code></li>
<li><code>unshift()</code></li>
<li><code>splice()</code></li>
<li><code>sort()</code></li>
<li><code>reverse()</code></li>
</ul>
<h3 id="变异园里的代码模仿实现">变异园里的代码模仿实现</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">VueArray</span> <span style="color:#66d9ef">extends</span> Array{
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">push</span>(...<span style="color:#a6e22e">args</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">oldLength</span><span style="color:#f92672">=</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">length</span>  
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">super</span>.<span style="color:#a6e22e">push</span>(...<span style="color:#a6e22e">args</span>)
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">=</span><span style="color:#a6e22e">oldLength</span>;<span style="color:#a6e22e">i</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">length</span>;<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">Vue</span>.<span style="color:#a6e22e">set</span>(<span style="color:#66d9ef">this</span>,<span style="color:#a6e22e">i</span>,<span style="color:#66d9ef">this</span>[<span style="color:#a6e22e">i</span>])   <span style="color:#75715e">//将每一个新增的key都告诉Vue
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="小结">小结</h1>
<p>Vue是以数据响应式为核心的UI框架，核心思想就是把所有的数据放到一个对象里，然后去操作对象，对象就会改变数据，监听这个改变从而改变UI，当然Vue不能检测到对象属性的添加或删除，如果一开始没有在Data上声明属性，就算你对这个属性做出更改，也不会更新UI。解决的方法是手动调用Vue.set或者this.$set(注意：此处的this等于vm）</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://zkh176.github.io/" >
    &copy;  浅岸的博客 2022 
  </a>
    <div>
<div class="ananke-socials">
  
</div></div>
  </div>
</footer>

  </body>
</html>
